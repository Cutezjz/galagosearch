#summary Galago Query Language

= Introduction =

This page describes the syntax and operators in the galago query language. It also describes each of the parameters and default values that each operator provides. 

Note that this query language is built upon and extends the * [http://sourceforge.net/apps/trac/lemur/wiki/The%20Indri%20Query%20Language Indri Query Language ] *.  While many indri queries will run in Galago as is, there are currently some differences, and some operators that do not yet exist.

One particular novel addition to the galago query is the presence of traversals. A traversal transforms a query from one form into another. Traversals are used internally to annotate or transform query nodes with additional information that can be extracted from the retrieval object. Traversals can be user specified in a parameter file.

= Syntax =

All components of the Galago query language are operators, as such they all conform to the following form:

{{{
 node := '#' <operator> [ ':' [ <key> '='] <value> ]* '(' [ <node> ]* ')'
 operator := [ a-z A-Z 0-9 ] +
 key := <value>
 value := [^ '=' '(' ')' ] +
}}}

= Query Parsing =

However entering in queries in this form would be tiresome. To make life a little easier, we provide two shortcuts. First a plain text term is parsed using an implicit 'text' operator.

{{{
 a --> #text : a ()
}}}

Second periods are used as a shortcut for the inside operator. Note that when a period is used in a key-value parameter pair the shortcut does not apply.

{{{
 #op : key = a.b ( c.d )--> #op: key = a.b ( #inside( #text:c() #text:d() )
}}}


= Operators =

=== #extents ===

=== #counts ===

=== #feature ===

=== #combine ===

=== #filter ===

=== #threshold === 

=== #syn | #synonym ===


= Traversal Pseudo-Operators =

The operators listed here are available for users, however they are transformed within a traversal to use true operators. (Listed below in order of traversal application.)

=== #prms( a b ) ===

See [ImplementingPRMS Implementing PRMS]

=== #seqdep ===

Sequential dependency retrieval model traversal.

|| Transformed by || SequentialDependenceTraversal ||  
|| Parameter: uniw || Weight of unigram component || default = 0.8 ||
|| Parameter: odw || Weight of ordered window component || default = 0.15 ||
|| Parameter: uww || Weight of unordered window component ||default = 0.05 ||

Example:

*Input:*
{{{ 
#seqdep( #text:a() #text:b() #text:c() )
}}}

*Output*
{{{ 
#combine:0=0.8:1=0.15:2=0.05 (  
          #combine( #text:a() #text:b() #text:c ) 
          #combine( #od:1(#text:a() #text:b() ) #od:1(#text:b() #text:c() ) ) 
          #combine( #uw:8(#text:a() #text:b() ) #uw:8(#text:b() #text:c() ) ) ) 
}}} 


=== #fulldep ===

Full dependency retrieval model traversal.

|| Transformed by || FullDependenceTraversal ||
|| Parameter: windowLimit || Maximum window operator size || default = -1 ||
|| Parameter: uniw || Weight of unigram component || default = 0.8 ||
|| Parameter: odw || Weight of ordered window component || default = 0.15 ||
|| Parameter: uww || Weight of unordered window component ||default = 0.05 ||

Example:

*Input:*
{{{ 
#fulldep( #text:a() #text:b() #text:c() )
}}}

*Output*
{{{ 
#combine:0=0.8:1=0.15:2=0.05 (  
          #combine( #text:a() #text:b() #text:c ) 
          #combine( 
                  #od:1(#text:a() #text:b() ) #od:1(#text:b() #text:c() ) 
                  #od:1(#text:a() #text:c() ) #od:1(#text:a() #text:b() #text:c() ) ) 
          #combine( 
                  #uw:8(#text:a() #text:b() ) #uw:8(#text:b() #text:c() ) 
                  #uw:8(#text:a() #text:c() ) #uw:12(#text:a() #text:b() #text:c() ) ) 
}}} 

=== #root ===

The root node is generated as the root of the query tree for a query with multiple parts. It is used as a place holder until the type of the query is known. Single node queries are not annotated with a root.

|| Transformed by || TransformRootTraversal ||
|| Parameter: queryType || Determines the type of transformation is required. || default = 'ranked' ||
||  || Possible selections : {{{[ boolean | count | ranked ]}}} ||

Example:

*Input*
{{{
#root:queryType=boolean( A B )
#root:queryType=count( A B )
#root:queryType=ranked( A B )
}}}

*Output*
{{{
#any( A B )
#synonym( A B )
#combine( A B )
}}}

=== #inside ===

This is a little difficult to explain right now...


=== #ngram ===

Soon to be replaced by something else...

=== #weight ===

Indri compatibility traversal - weight -> combine

=== Indri Window Operators (#odN #1 #uwN) ===

Window compatibility traversal  --> #odN -> #od:N


=== #text ===

|| Transformed by || TextFieldRewriteTraversal ||
|| Input || #text:term() ||
|| Output || #extents: stem(term) : part = stemmedPostings() ||
|| Output || #extents: term : part = postings() ||

*Comments:* This traversal selects uses stemmed postings by default, if so it will stem the term. If there is no stemmedPostings part available then it will use the postings part.

=== #field ===

|| Transformed by || TextFieldRewriteTraversal ||

=== #rm ===

Relevence modelling


=== #bm25rf ===

Similar but for bm25 relevence feedback